/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["mathematica"] = factory();
	else
		root["mathematica"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ast-node.js":
/*!*************************!*\
  !*** ./src/ast-node.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ASTNode\": () => (/* binding */ ASTNode)\n/* harmony export */ });\nclass ASTNode {\r\n    constructor(type, childNode, value) {\r\n      this.symbols = new Set();\r\n      this.child = childNode;\r\n      this.value = value;\r\n      this.type = type;\r\n    }\r\n}\n\n//# sourceURL=webpack://mathematica/./src/ast-node.js?");

/***/ }),

/***/ "./src/big-integer.js":
/*!****************************!*\
  !*** ./src/big-integer.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BigInteger\": () => (/* binding */ BigInteger)\n/* harmony export */ });\nclass BigInteger {\r\n  static _base = 10;\r\n  // In rowDec, there's a _base^compressDegree base number\r\n  static compressDegree = 4;\r\n  static realBase = this._base ** this.compressDegree;\r\n  constructor(num) {\r\n    this.rawDec = [];\r\n    this.decimal = [];\r\n    this.positive = true;\r\n    if (num) {\r\n      this.parse(num);\r\n    }\r\n  }\r\n\r\n  clone() {\r\n    const ret = new BigInteger(this.rawDec);\r\n    ret.positive = this.positive;\r\n    return ret;\r\n  }\r\n\r\n  parseNumber(_num) {\r\n    if (_num < 0) {\r\n      this.positive = false;\r\n      _num = -_num;\r\n    }\r\n    let num = _num;\r\n    this.rawDec = [];\r\n    while (num !== 0) {\r\n      this.rawDec.push(num % BigInteger.realBase);\r\n      num = parseInt(num / BigInteger.realBase, BigInteger._base);\r\n    }\r\n  }\r\n\r\n  parseString(_numStr) {\r\n    if (_numStr[0] === '-') {\r\n      _numStr = _numStr.slice(1);\r\n      this.positive = false;\r\n    }\r\n    const numStr = this.trimLeadingZero(_numStr).split('.');\r\n    this.rawDec = [];\r\n    let numIndex = numStr[0].length - 1;\r\n    let rawDecIndex = 0;\r\n    while (numIndex >= 0) {\r\n      this.rawDec.push(0);\r\n      rawDecIndex = this.rawDec.length - 1;\r\n\r\n      for (let i = BigInteger.compressDegree - 1; i >= 0; i--) {\r\n        this.rawDec[rawDecIndex] = this.rawDec[rawDecIndex] * BigInteger._base + parseInt(numStr[0][numIndex - i] ?? 0, BigInteger._base);\r\n      }\r\n\r\n      numIndex -= BigInteger.compressDegree;\r\n    }\r\n  }\r\n\r\n  parse(num) {\r\n    if (Array.isArray(num)) {\r\n      this.rawDec = num;\r\n      return;\r\n    }\r\n    switch (typeof (num)) {\r\n      case 'number':\r\n        this.parseNumber(num);\r\n        this.positive = num > 0;\r\n        break;\r\n      case 'string':\r\n        this.parseString(num);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  trimLeadingZero(numStr) {\r\n    return numStr.replace(/^0+/, '');\r\n  }\r\n\r\n  toString() {\r\n    if (this.isZero()) {\r\n      return '0';\r\n    }\r\n    const rawDecDummy = this.rawDec.slice(0);\r\n    let result = '';\r\n    while (rawDecDummy.length > 0) {\r\n      let currentSegment = rawDecDummy.pop();\r\n      let temp = '';\r\n      for (let i = 0; i < BigInteger.compressDegree; i++) {\r\n        const digit = currentSegment % BigInteger._base;\r\n        temp = digit.toString() + temp;\r\n        currentSegment = parseInt(currentSegment / BigInteger._base, BigInteger._base);\r\n      }\r\n      result += temp;\r\n    }\r\n    result = this.trimLeadingZero(result);\r\n    if (this.positive === false) {\r\n      result = `-${result}`;\r\n    }\r\n    return result;\r\n  }\r\n  inverse() {\r\n    const result = new BigInteger(this.rawDec);\r\n    result.positive = !this.positive;\r\n    return result;\r\n  }\r\n\r\n  linearOp(_num, op, nextCarry, isSwap) {\r\n    let carry = 0;\r\n    let selfArray = this.rawDec;\r\n    let anotherArray = _num.rawDec;\r\n    const result = [];\r\n    if (isSwap) {\r\n      const temp = selfArray;\r\n      selfArray = anotherArray;\r\n      anotherArray = temp;\r\n    }\r\n    for (let i = 0; i < selfArray.length || i < anotherArray.length; i++) {\r\n      const segmentSelf = selfArray[i] ?? 0;\r\n      const segmentAnother = anotherArray[i] ?? 0;\r\n      const segmentResult = (op(segmentSelf, segmentAnother, carry) + BigInteger.realBase) % BigInteger.realBase;\r\n      result.push(segmentResult);\r\n      carry = nextCarry(op(segmentSelf, segmentAnother, carry));\r\n    }\r\n    result.push(carry);\r\n    while (result[result.length - 1] === 0 && result.length > 1) {\r\n      result.pop();\r\n    }\r\n    return new BigInteger(result);\r\n  }\r\n  add(_num) {\r\n    let num = _num;\r\n    if (typeof (_num) === 'number' || typeof (_num) === 'string') {\r\n      num = new BigInteger(_num);\r\n    }\r\n    if (this.positive && num.positive) {\r\n      return this.linearOp(num, (first, second, carry) => first + second + carry, numPara => (numPara >= BigInteger.realBase ? 1 : 0));\r\n    } else if (!this.positive && !num.positive) {\r\n      return this.linearOp(num, (first, second, carry) => first + second + carry, numPara => (numPara >= BigInteger.realBase ? 1 : 0)).inverse();\r\n    } else if (this.positive) {\r\n      return this.minus(num.inverse());\r\n    }\r\n    return num.minus(this.inverse());\r\n  }\r\n  isZero() {\r\n    for (const digit of this.rawDec) {\r\n      if (digit !== 0) return false;\r\n    }\r\n    return true;\r\n  }\r\n  minus(_num) {\r\n    let num = _num;\r\n    if (typeof (_num) === 'number' || typeof (_num) === 'string') {\r\n      num = new BigInteger(_num);\r\n    }\r\n\r\n    if (!this.positive && !num.positive) {\r\n      return num.inverse().minus(this);\r\n    } else if (!this.positive && num.positive) {\r\n      return this.inverse().add(num).inverse();\r\n    } else if (this.positive && !num.positive) {\r\n      return this.add(num.inverse());\r\n    }\r\n\r\n    const isSwap = !this.largerThan(_num);\r\n    const result = this.linearOp(num, (first, second, carry) => first - second - carry, numPara => (numPara < 0 ? 1 : 0), isSwap);\r\n    if (isSwap) {\r\n      result.positive = false;\r\n    }\r\n    while (result.rawDec[result.rawDec.length - 1] === 0 && result.rawDec.length > 1) {\r\n      result.rawDec.pop();\r\n    }\r\n    return result;\r\n  }\r\n  multiply(_num) {\r\n    // TODO: FFT\r\n    let num = _num;\r\n    if (typeof (_num) === 'number' || typeof (_num) === 'string') {\r\n      num = new BigInteger(_num);\r\n    }\r\n    const result = [];\r\n    for (let i = 0; i < num.rawDec.length; i++) {\r\n      for (let j = 0; j < this.rawDec.length; j++) {\r\n        if (result[i + j] === undefined) {\r\n          result.push(0);\r\n        }\r\n        const tempResult = result[i + j] + num.rawDec[i] * this.rawDec[j];\r\n        result[i + j] = tempResult % BigInteger.realBase;\r\n        const carry = parseInt(tempResult / BigInteger.realBase, 10);\r\n        if (carry) {\r\n          if (result[i + j + 1] === undefined) {\r\n            result.push(0);\r\n          }\r\n          result[i + j + 1] += carry;\r\n        }\r\n      }\r\n    }\r\n    const ret = new BigInteger(result);\r\n    ret.positive = !(this.positive ^ num.positive);\r\n    return ret;\r\n  }\r\n  divide(_num) {\r\n    let num = _num;\r\n    if (typeof (_num) === 'number' || typeof (_num) === 'string') {\r\n      num = new BigInteger(_num);\r\n    }\r\n    const start = this.rawDec.length - num.rawDec.length;\r\n    if (start < 0) {\r\n      return new BigInteger(0);\r\n    }\r\n    let a = new BigInteger(this.rawDec.slice(start));\r\n    let ans = '';\r\n    for (let i = start; i >= 0; i--) {\r\n      let ansDigit = 0;\r\n      while (true) {\r\n        const b = a.minus(_num);\r\n        if (!b.positive && !b.isZero()) {\r\n          break;\r\n        }\r\n        ansDigit++;\r\n        a = b;\r\n      }\r\n      let ansDigitStr = ansDigit.toString();\r\n      while (ansDigitStr.length < BigInteger.compressDegree) {\r\n        ansDigitStr = `0${ansDigitStr}`;\r\n      }\r\n      ans += ansDigitStr;\r\n      a.rawDec.unshift(0);\r\n      if (i > 0) {\r\n        a.rawDec[0] = this.rawDec[i - 1];\r\n      }\r\n      while (a.rawDec[a.rawDec.length - 1] === 0 && a.rawDec.length > 1) {\r\n        a.rawDec.pop();\r\n      }\r\n      a.positive = true;\r\n    }\r\n    const retBigInteger = new BigInteger(ans);\r\n    retBigInteger.positive = !(this.positive ^ num.positive);\r\n    return retBigInteger;\r\n  }\r\n  largerThan(_num) {\r\n    let num = _num;\r\n    if (typeof (_num) === 'number' || typeof (_num) === 'string') {\r\n      num = new BigInteger(_num);\r\n    }\r\n    while (num.rawDec[num.rawDec.length - 1] === 0 && num.rawDec.length > 1) {\r\n      num.rawDec.pop();\r\n    }\r\n    while (this.rawDec[this.rawDec.length - 1] === 0 && this.rawDec.length > 1) {\r\n      this.rawDec.pop();\r\n    }\r\n    if (num.rawDec.length !== this.rawDec.length) {\r\n      return (this.rawDec.length > num.rawDec.length);\r\n    }\r\n    for (let i = num.rawDec.length - 1; i >= 0; i--) {\r\n      if (this.rawDec[i] !== num.rawDec[i]) {\r\n        return this.rawDec[i] > num.rawDec[i];\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  isEqual(_num) {\r\n    let num = _num;\r\n    if (typeof (_num) === 'number' || typeof (_num) === 'string') {\r\n      num = new BigInteger(_num);\r\n    }\r\n    while (num.rawDec[num.rawDec.length - 1] === 0 && num.rawDec.length > 1) {\r\n      num.rawDec.pop();\r\n    }\r\n    while (this.rawDec[this.rawDec.length - 1] === 0 && this.rawDec.length > 1) {\r\n      this.rawDec.pop();\r\n    }\r\n    if (num.rawDec.length !== this.rawDec.length) {\r\n      return false;\r\n    }\r\n    for (let i = num.rawDec.length - 1; i >= 0; i--) {\r\n      if (this.rawDec[i] !== num.rawDec[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    if (num.positive !== this.positive) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n}\n\n//# sourceURL=webpack://mathematica/./src/big-integer.js?");

/***/ }),

/***/ "./src/exponent-ast-node.js":
/*!**********************************!*\
  !*** ./src/exponent-ast-node.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ExponentASTNode\": () => (/* binding */ ExponentASTNode)\n/* harmony export */ });\n/* harmony import */ var _ast_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast-node */ \"./src/ast-node.js\");\n/* harmony import */ var _integer_ast_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./integer-ast-node */ \"./src/integer-ast-node.js\");\n/* harmony import */ var _big_integer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./big-integer */ \"./src/big-integer.js\");\n/* harmony import */ var _factor_ast_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./factor-ast-node */ \"./src/factor-ast-node.js\");\n/* harmony import */ var _term_ast_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./term-ast-node */ \"./src/term-ast-node.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass ExponentASTNode extends _ast_node__WEBPACK_IMPORTED_MODULE_0__.ASTNode {\r\n    constructor(base, power) {\r\n      super('Exponent', null);\r\n      this.base = base;\r\n      this.power = power;\r\n    }\r\n    add(power) {\r\n      this.power = power;\r\n    }\r\n    getSimplify() {\r\n      if (!this.power) {\r\n        return this.base;\r\n      }\r\n      if (this.power.type === 'integer' && this.power?.obj === '1') {\r\n        return this.base;\r\n      }\r\n      return this;\r\n    }\r\n    quickPower(base, power) {\r\n      if (power.isZero()) {\r\n        return new _big_integer__WEBPACK_IMPORTED_MODULE_2__.BigInteger(1);\r\n      }\r\n      if (power.rawDec[0] & 1) {\r\n        return base.multiply(this.quickPower(base, power.minus(1)));\r\n      }\r\n      const temp = this.quickPower(base, power.divide(2));\r\n      return temp.multiply(temp);\r\n    }\r\n    compute() {\r\n      const base = this.base.compute();\r\n      const power = this.power.compute();\r\n      if (base.type === 'integer' && power.type === 'integer') {\r\n        let result = new _big_integer__WEBPACK_IMPORTED_MODULE_2__.BigInteger(1);\r\n        if (power.value.positive) {\r\n          result = this.quickPower(base.value, power.value);\r\n        }\r\n        return new _integer_ast_node__WEBPACK_IMPORTED_MODULE_1__.IntegerASTNode(result.toString());\r\n      }\r\n      const ret = new ExponentASTNode(base, power).getSimplify();\r\n      for (const element of base.symbols) {\r\n        ret.symbols.add(element);\r\n      }\r\n      for (const element of power.symbols) {\r\n        ret.symbols.add(element);\r\n      }\r\n      return ret;\r\n    }\r\n  \r\n    toString() {\r\n      if (this.strRaw) {\r\n        return this.strRaw;\r\n      }\r\n      const base = this.base.toString();\r\n      const power = this.power.toString();\r\n      this.strRaw = `${base} ^ ${power}`;\r\n      return this.strRaw;\r\n    }\r\n    clone() {\r\n      return new ExponentASTNode(this.base, this.power);\r\n    }\r\n    derivative(symbol) {\r\n      if (!this.power.symbols.has(symbol)) {\r\n        const result = new _factor_ast_node__WEBPACK_IMPORTED_MODULE_3__.FactorASTNode();\r\n        result.add('multiply', this.power.clone());\r\n        const minusOne = new _term_ast_node__WEBPACK_IMPORTED_MODULE_4__.TermASTNode(this.power.clone());\r\n        minusOne.add('minus', new _integer_ast_node__WEBPACK_IMPORTED_MODULE_1__.IntegerASTNode('1'));\r\n        result.add('multiply', new ExponentASTNode(this.base, minusOne));\r\n        return result;\r\n      }\r\n    }\r\n  }\n\n//# sourceURL=webpack://mathematica/./src/exponent-ast-node.js?");

/***/ }),

/***/ "./src/factor-ast-node.js":
/*!********************************!*\
  !*** ./src/factor-ast-node.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FactorASTNode\": () => (/* binding */ FactorASTNode)\n/* harmony export */ });\n/* harmony import */ var _ast_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast-node */ \"./src/ast-node.js\");\n/* harmony import */ var _term_ast_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./term-ast-node */ \"./src/term-ast-node.js\");\n/* harmony import */ var _big_integer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./big-integer */ \"./src/big-integer.js\");\n/* harmony import */ var _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./integer-ast-node */ \"./src/integer-ast-node.js\");\n/* harmony import */ var _exponent_ast_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./exponent-ast-node */ \"./src/exponent-ast-node.js\");\n/* harmony import */ var _unary_ast_node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./unary-ast-node */ \"./src/unary-ast-node.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass FactorASTNode extends _ast_node__WEBPACK_IMPORTED_MODULE_0__.ASTNode {\r\n    constructor(value) {\r\n      super('factor', []);\r\n      if (value) {\r\n        this.add('multiply', value);\r\n      }\r\n    }\r\n    add(type, value) {\r\n      this.child.push({ type, value });\r\n    }\r\n  \r\n    combine() {\r\n      const childStrMap = new Map();\r\n      this.child.forEach((factor) => {\r\n        let str = factor.value.toString();\r\n        let num = new _big_integer__WEBPACK_IMPORTED_MODULE_2__.BigInteger(1);\r\n        if (factor.value.type === 'Exponent' && factor.value.power.type === 'integer') {\r\n          str = factor.value.base.toString();\r\n          num = factor.value.power.compute().value;\r\n        }\r\n        const count = childStrMap.get(str);\r\n        if (count) {\r\n          childStrMap.set(str, count.add(num));\r\n          if (factor.type === 'multiply') {\r\n            childStrMap.set(str, count.add(num));\r\n          } else {\r\n            childStrMap.set(str, count.minus(num));\r\n          }\r\n        } else {\r\n          if (factor.type === 'multiply') {\r\n            childStrMap.set(str, num);\r\n          } else {\r\n            childStrMap.set(str, num.inverse());\r\n          }\r\n        }\r\n      });\r\n      const newChild = [];\r\n      this.child.forEach((factor) => {\r\n        let str = factor.value.toString();\r\n        let base = factor.value;\r\n        if (factor.value.type === 'Exponent' && factor.value.power.type === 'integer') {\r\n          str = factor.value.base.toString();\r\n          base = factor.value.base;\r\n        }\r\n  \r\n        const count = childStrMap.get(str);\r\n        if (count.isZero()) {\r\n          return;\r\n        }\r\n        if (count.isEqual(1)) {\r\n          factor.type = 'multiply';\r\n          newChild.push(factor);\r\n        } else if (count.isEqual(-1)) {\r\n          factor.type = 'divide';\r\n          newChild.push(factor);\r\n        } else {\r\n          const result = new _exponent_ast_node__WEBPACK_IMPORTED_MODULE_4__.ExponentASTNode(base);\r\n          result.add(new _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__.IntegerASTNode(count.toString()));\r\n          factor.value = result;\r\n          factor.type = 'multiply';\r\n          newChild.push(factor);\r\n        }\r\n        childStrMap.set(str, new _big_integer__WEBPACK_IMPORTED_MODULE_2__.BigInteger(0));\r\n      });\r\n      this.child = newChild;\r\n    }\r\n  \r\n    getSimplify() {\r\n      const factorChild = this.child?.filter(child => child.value.type === 'factor' && child.type === 'multiply');\r\n      this.child = this.child?.filter(child => child.value.type !== 'factor' || child.type !== 'multiply');\r\n  \r\n      factorChild.forEach((factor) => {\r\n        factor.value.child.forEach((child) => {\r\n          this.child.push(child);\r\n        });\r\n      });\r\n      this.child = this.child?.filter((child) => {\r\n        if (child.value.type === 'integer') {\r\n          return child.value?.obj !== '1';\r\n        }\r\n        return true;\r\n      });\r\n      const zero = this.child?.filter((child) => {\r\n        if (child.value.type === 'integer') {\r\n          return child.value?.obj === '0';\r\n        }\r\n        return false;\r\n      });\r\n      if (zero.length > 0) {\r\n        return new _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__.IntegerASTNode('0').compute();\r\n      }\r\n      if (this.child.length === 0) {\r\n        return new _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__.IntegerASTNode('1').compute();\r\n      }\r\n  \r\n      this.combine();\r\n      if (this.child.length === 1 && this.child[0].type === 'multiply') {\r\n        return this.child[0].value;\r\n      }\r\n      if (this.child.length === 0) {\r\n        return new _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__.IntegerASTNode('1').compute();\r\n      }\r\n  \r\n      let negativeCount = 0;\r\n      this.child?.forEach((child) => {\r\n        if (child.value.type === 'negative') {\r\n          child.value = child.value.child;\r\n          negativeCount++;\r\n        } else if (child.value.type === 'positive') {\r\n          child.value = child.value.child;\r\n        }\r\n      });\r\n      if (negativeCount & 1) {\r\n        return new _unary_ast_node__WEBPACK_IMPORTED_MODULE_5__.UnaryASTNode('negative', this);\r\n      }\r\n  \r\n      return this;\r\n    }\r\n    compute() {\r\n      const ret = new FactorASTNode();\r\n      const multiplyList = this.child.filter(x => x.type === 'multiply').map(x => x.value.compute());\r\n      const divideList = this.child.filter(x => x.type === 'divide').map(x => x.value.compute());\r\n  \r\n      const incomputableMultiplyList = multiplyList.filter(x => x.type !== 'integer');\r\n      const integerMultiplyList = multiplyList.filter(x => x.type === 'integer').reduce((x, y) => {\r\n        const result = x.value.multiply(y.value);\r\n        const _ret = new _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__.IntegerASTNode(result.toString());\r\n        _ret.value = result;\r\n        return _ret;\r\n      }, new _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__.IntegerASTNode('1').compute());\r\n  \r\n      const incomputableDivideList = divideList.filter(x => x.type !== 'integer');\r\n      const integerDivideList = divideList.filter(x => x.type === 'integer').reduce((x, y) => {\r\n        const result = x.value.multiply(y.value);\r\n        const _ret = new _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__.IntegerASTNode(result.toString());\r\n        _ret.value = result;\r\n        return _ret;\r\n      }, new _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__.IntegerASTNode('1').compute());\r\n  \r\n      ret.add('multiply', integerMultiplyList);\r\n      incomputableMultiplyList.forEach((x) => {\r\n        for (const element of x.symbols) {\r\n          ret.symbols.add(element);\r\n        }\r\n        ret.add('multiply', x);\r\n      });\r\n  \r\n      ret.add('divide', integerDivideList);\r\n      incomputableDivideList.forEach((x) => {\r\n        for (const element of x.symbols) {\r\n          ret.symbols.add(element);\r\n        }\r\n        ret.add('divide', x);\r\n      });\r\n      return ret.getSimplify();\r\n    }\r\n    derivative(symbol) {\r\n      const ret = new _term_ast_node__WEBPACK_IMPORTED_MODULE_1__.TermASTNode();\r\n      for (let i = 0; i < this.child.length; i++) {\r\n        const term = this.clone();\r\n        term.child[i].value = term.child[i].value.derivative(symbol);\r\n        ret.add('add', term);\r\n      }\r\n      return ret.getSimplify();\r\n    }\r\n    clone() {\r\n      const ret = new FactorASTNode();\r\n      for (let i = 0; i < this.child.length; i++) {\r\n        ret.add(this.child[i].type, this.child[i].value.clone());\r\n      }\r\n      return ret;\r\n    }\r\n  \r\n    toString() {\r\n      if (this.strRaw) {\r\n        return this.strRaw;\r\n      }\r\n      let result = this.child[0].value.toString();\r\n      let hasMultiply = this.child[0].type === 'multiply';\r\n      for (let i = 1; i < this.child.length; i++) {\r\n        const another = this.child[i].value.toString();\r\n        switch (this.child[i].type) {\r\n          case 'multiply':\r\n            result += ` * ${another}`;\r\n            hasMultiply = 1;\r\n            break;\r\n          case 'divide':\r\n            result += ` / ${another}`;\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      }\r\n      if (hasMultiply === 0) {\r\n        result = `(1 / ${result})`;\r\n      }\r\n      this.strRaw = result;\r\n      return this.strRaw;\r\n    }\r\n  }\n\n//# sourceURL=webpack://mathematica/./src/factor-ast-node.js?");

/***/ }),

/***/ "./src/function-ast-node.js":
/*!**********************************!*\
  !*** ./src/function-ast-node.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FunctionASTNode\": () => (/* binding */ FunctionASTNode)\n/* harmony export */ });\n/* harmony import */ var _ast_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast-node */ \"./src/ast-node.js\");\n/* harmony import */ var _unary_ast_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unary-ast-node */ \"./src/unary-ast-node.js\");\n/* harmony import */ var _factor_ast_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./factor-ast-node */ \"./src/factor-ast-node.js\");\n/* harmony import */ var _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./integer-ast-node */ \"./src/integer-ast-node.js\");\n\r\n\r\n\r\n\r\n\r\nclass FunctionASTNode extends _ast_node__WEBPACK_IMPORTED_MODULE_0__.ASTNode {\r\n    constructor(functionName, parameter) {\r\n      super('function');\r\n      this.parameter = parameter;\r\n      this.functionName = functionName;\r\n    }\r\n    compute() {\r\n      const ret = this.clone();\r\n      ret.parameter = ret.parameter.compute();\r\n      return ret;\r\n    }\r\n    clone() {\r\n      const ret = new FunctionASTNode(this.functionName, this.parameter.clone());\r\n      return ret;\r\n    }\r\n    toString() {\r\n      let ret;\r\n      if (this.parameter.type === 'term') {\r\n        ret = `${this.functionName}${this.parameter.toString()}`;\r\n      } else {\r\n        ret = `${this.functionName}(${this.parameter.toString()})`;\r\n      }\r\n      return ret;\r\n    }\r\n    functionDerivativeProcess(functionAst) {\r\n      let ret;\r\n      switch (functionAst.functionName) {\r\n        case 'sin':\r\n          functionAst.functionName = 'cos';\r\n          ret = functionAst;\r\n          break;\r\n        case 'exp':\r\n          functionAst.functionName = 'exp';\r\n          ret = functionAst;\r\n          break;\r\n        case 'cos':\r\n          functionAst.functionName = 'sin';\r\n          ret = new _unary_ast_node__WEBPACK_IMPORTED_MODULE_1__.UnaryASTNode('negative', functionAst);\r\n          break;\r\n        case 'ln':\r\n          ret = new _factor_ast_node__WEBPACK_IMPORTED_MODULE_2__.FactorASTNode(new _integer_ast_node__WEBPACK_IMPORTED_MODULE_3__.IntegerASTNode('1'));\r\n          ret.add('divide', functionAst.parameter);\r\n          break;\r\n        default:\r\n          functionAst.functionName = `${functionAst.functionName}'`;\r\n          ret = functionAst;\r\n      }\r\n      return ret;\r\n    }\r\n    derivative(symbol) {\r\n      const rightPart = this.functionDerivativeProcess(this.clone());\r\n      const ret = new _factor_ast_node__WEBPACK_IMPORTED_MODULE_2__.FactorASTNode(rightPart);\r\n      ret.add('multiply', this.parameter.derivative(symbol));\r\n      return ret;\r\n    }\r\n  }\r\n  \n\n//# sourceURL=webpack://mathematica/./src/function-ast-node.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Lexical\": () => (/* reexport safe */ _parser__WEBPACK_IMPORTED_MODULE_0__.Lexical)\n/* harmony export */ });\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser */ \"./src/parser.js\");\n\r\n\r\n\n\n//# sourceURL=webpack://mathematica/./src/index.js?");

/***/ }),

/***/ "./src/integer-ast-node.js":
/*!*********************************!*\
  !*** ./src/integer-ast-node.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IntegerASTNode\": () => (/* binding */ IntegerASTNode)\n/* harmony export */ });\n/* harmony import */ var _ast_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast-node */ \"./src/ast-node.js\");\n/* harmony import */ var _big_integer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./big-integer */ \"./src/big-integer.js\");\n\r\n\r\n\r\nclass IntegerASTNode extends _ast_node__WEBPACK_IMPORTED_MODULE_0__.ASTNode {\r\n    constructor(value) {\r\n      super('integer', null);\r\n      if (value.rawDec) {\r\n        this.obj = value.toString();\r\n        this.value = value;\r\n      }\r\n      this.obj = value;\r\n    }\r\n    compute() {\r\n      const ret = this.clone();\r\n      ret.value = this.value ?? new _big_integer__WEBPACK_IMPORTED_MODULE_1__.BigInteger(this.obj);\r\n      return ret;\r\n    }\r\n    toString() {\r\n      return this.obj;\r\n    }\r\n    clone() {\r\n      return new IntegerASTNode(this.obj);\r\n    }\r\n    derivative() {\r\n      const result = new IntegerASTNode('0');\r\n      return result;\r\n    }\r\n  }\n\n//# sourceURL=webpack://mathematica/./src/integer-ast-node.js?");

/***/ }),

/***/ "./src/parser.js":
/*!***********************!*\
  !*** ./src/parser.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Lexical\": () => (/* binding */ Lexical)\n/* harmony export */ });\n/* harmony import */ var _big_integer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./big-integer */ \"./src/big-integer.js\");\n/* harmony import */ var _integer_ast_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./integer-ast-node */ \"./src/integer-ast-node.js\");\n/* harmony import */ var _term_ast_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./term-ast-node */ \"./src/term-ast-node.js\");\n/* harmony import */ var _factor_ast_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./factor-ast-node */ \"./src/factor-ast-node.js\");\n/* harmony import */ var _exponent_ast_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./exponent-ast-node */ \"./src/exponent-ast-node.js\");\n/* harmony import */ var _function_ast_node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function-ast-node */ \"./src/function-ast-node.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst LEX_STATE = {\r\n  VACANT: 0,\r\n  RECEIVED_FUNC: 1,\r\n  RECEIVED_NUM: 2,\r\n};\r\n\r\nclass Token {\r\n  constructor(type, content) {\r\n    this.type = type;\r\n    this.content = content;\r\n  }\r\n}\r\n\r\nclass ParseResult {\r\n  constructor(index, type, ast, value) {\r\n    this.index = index;\r\n    this.type = type;\r\n    this.ast = ast;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\nclass ASTNode {\r\n  constructor(type, childNode, value) {\r\n    this.symbols = new Set();\r\n    this.child = childNode;\r\n    this.value = value;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\n\r\n\r\nclass SymbolASTNode extends ASTNode {\r\n  constructor(symbolName) {\r\n    super('symbol');\r\n    this.symbolName = symbolName;\r\n    this.symbols.add(symbolName);\r\n  }\r\n  compute() {\r\n    const ret = this.clone();\r\n    return ret;\r\n  }\r\n  toString() {\r\n    return this.symbolName;\r\n  }\r\n  clone() {\r\n    return new SymbolASTNode(this.symbolName);\r\n  }\r\n  derivative(symbol) {\r\n    let result;\r\n    if (this.symbolName === symbol) {\r\n      result = new _integer_ast_node__WEBPACK_IMPORTED_MODULE_1__.IntegerASTNode('1');\r\n    } else {\r\n      result = new _integer_ast_node__WEBPACK_IMPORTED_MODULE_1__.IntegerASTNode('0');\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\nclass Lexical {\r\n  constructor(str) {\r\n    this.symbols = new Set();\r\n    this.tokens = [];\r\n    if (str) {\r\n      this.generateTokens(str);\r\n    }\r\n  }\r\n\r\n  setSym(symbol) {\r\n    this.symbols.add(symbol);\r\n  }\r\n\r\n  singleCharacterProcess(charactor) {\r\n    switch (charactor) {\r\n      case '+':\r\n      case '-':\r\n      case '*':\r\n      case '/':\r\n        this.tokens.push(new Token('sign', charactor));\r\n        return LEX_STATE.VACANT;\r\n      case '(':\r\n      case ')':\r\n        this.tokens.push(new Token('parentheses', charactor));\r\n        return LEX_STATE.VACANT;\r\n      case '\\t':\r\n      case '\\n':\r\n      case ' ':\r\n        return LEX_STATE.VACANT;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  vacantProcess(charactor) {\r\n    switch (charactor) {\r\n      case '+':\r\n      case '-':\r\n      case '*':\r\n      case '/':\r\n      case '^':\r\n      case '=':\r\n        this.tokens.push(new Token('sign', charactor));\r\n        return LEX_STATE.VACANT;\r\n      case '(':\r\n      case ')':\r\n        this.tokens.push(new Token('parentheses', charactor));\r\n        return LEX_STATE.VACANT;\r\n      case '\\t':\r\n      case '\\n':\r\n      case ' ':\r\n        return LEX_STATE.VACANT;\r\n      default:\r\n        break;\r\n    }\r\n    if (/^[_a-zA-Z|\\/|\\\\]$/.test(charactor)) {\r\n      this.tokens.push(new Token('function', charactor));\r\n      return LEX_STATE.RECEIVED_FUNC;\r\n    }\r\n    if (/^[0-9]$/.test(charactor)) {\r\n      this.tokens.push(new Token('integer', charactor));\r\n      return LEX_STATE.RECEIVED_NUM;\r\n    }\r\n  }\r\n\r\n  receiveFuncProcess(charactor) {\r\n    if (/^[_0-9a-zA-Z|\\\\]$/.test(charactor)) {\r\n      const latestToken = this.tokens.pop();\r\n      latestToken.content += charactor;\r\n      this.tokens.push(latestToken);\r\n      return LEX_STATE.RECEIVED_FUNC;\r\n    }\r\n    return this.vacantProcess(charactor);\r\n  }\r\n\r\n  receiveIntegerProcess(charactor) {\r\n    if (/^[0-9]$/.test(charactor)) {\r\n      const latestToken = this.tokens.pop();\r\n      latestToken.content += charactor;\r\n      this.tokens.push(latestToken);\r\n      return LEX_STATE.RECEIVED_NUM;\r\n    }\r\n    return this.vacantProcess(charactor);\r\n  }\r\n\r\n  generateTokens(str) {\r\n    let currentState = LEX_STATE.VACANT;\r\n    for (const charactor of str) {\r\n      switch (currentState) {\r\n        case LEX_STATE.VACANT:\r\n          currentState = this.vacantProcess(charactor);\r\n          break;\r\n        case LEX_STATE.RECEIVED_FUNC:\r\n          currentState = this.receiveFuncProcess(charactor);\r\n          break;\r\n        case LEX_STATE.RECEIVED_NUM:\r\n          currentState = this.receiveIntegerProcess(charactor);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    for (const token of this.tokens) {\r\n      if (token.type === 'function' && this.symbols.has(token.content)) {\r\n        token.type = 'symbol';\r\n      }\r\n    }\r\n    return this.tokens;\r\n  }\r\n\r\n  /*\r\n    expr → + unary | - unary\r\n    unary\t→ term { + term | - term }\r\n    term\t→ factor { * factor | / factor }\r\n    factor -> power ^ power\r\n    power\t→ ( expr ) | digit | fun()\r\n  */\r\n\r\n  findPower(tokenIndex) {\r\n    let currentIndex = tokenIndex;\r\n    const firstToken = this.tokens[currentIndex];\r\n    if (firstToken?.content === '(') {\r\n      const result = this.findExpression(currentIndex + 1);\r\n      currentIndex = result.index;\r\n      if (this.tokens[currentIndex]?.content !== ')') {\r\n        throw Error('parentheses is not match');\r\n      }\r\n      return new ParseResult(currentIndex + 1, 'expression', result.ast);\r\n    }\r\n    if (firstToken.type === 'integer') {\r\n      return new ParseResult(currentIndex + 1, firstToken.type, new _integer_ast_node__WEBPACK_IMPORTED_MODULE_1__.IntegerASTNode(firstToken.content));\r\n    }\r\n    if (firstToken.type === 'symbol') {\r\n      return new ParseResult(currentIndex + 1, firstToken.type, new SymbolASTNode(firstToken.content));\r\n    }\r\n    if (firstToken.type === 'function' && this.tokens[currentIndex + 1].content === '(') {\r\n      const result = this.findExpression(currentIndex + 2);\r\n      currentIndex = result.index;\r\n      if (this.tokens[currentIndex]?.content !== ')') {\r\n        throw Error('parentheses is not match');\r\n      }\r\n      const ast = {};\r\n      ast.functionName = firstToken.content;\r\n      ast.parameter = result.ast;\r\n      return new ParseResult(currentIndex + 1, firstToken.type, new _function_ast_node__WEBPACK_IMPORTED_MODULE_5__.FunctionASTNode(firstToken.content, result.ast));\r\n    }\r\n    if (firstToken?.content === '+') {\r\n      const temp = this.findTerm(tokenIndex + 1);\r\n      const ast = new UnaryASTNode('positive', temp.ast);\r\n      currentIndex = temp.index;\r\n      return new ParseResult(currentIndex, 'expression', ast);\r\n    } else if (firstToken?.content === '-') {\r\n      const temp = this.findTerm(tokenIndex + 1);\r\n      const ast = new UnaryASTNode('negative', temp.ast);\r\n      currentIndex = temp.index;\r\n      return new ParseResult(currentIndex, 'expression', ast);\r\n    }\r\n  }\r\n\r\n  findFactor(tokenIndex) {\r\n    const result = this.findPower(tokenIndex);\r\n    let currentIndex = result.index;\r\n    const ast = new _exponent_ast_node__WEBPACK_IMPORTED_MODULE_4__.ExponentASTNode(result.ast);\r\n    if (this.tokens[currentIndex]?.content === '^') {\r\n      const temp = this.findPower(currentIndex + 1);\r\n      ast.add(temp.ast);\r\n      currentIndex = temp.index;\r\n    }\r\n    return new ParseResult(currentIndex, 'term', ast.getSimplify());\r\n  }\r\n\r\n  findTerm(tokenIndex) {\r\n    const result = this.findFactor(tokenIndex);\r\n    let currentIndex = result.index;\r\n    const ast = new _factor_ast_node__WEBPACK_IMPORTED_MODULE_3__.FactorASTNode(result.ast);\r\n    while (true) {\r\n      if (this.tokens[currentIndex]?.content === '*') {\r\n        const temp = this.findFactor(currentIndex + 1);\r\n        ast.add('multiply', temp.ast);\r\n        currentIndex = temp.index;\r\n      } else if (this.tokens[currentIndex]?.content === '/') {\r\n        const temp = this.findFactor(currentIndex + 1);\r\n        ast.add('divide', temp.ast);\r\n        currentIndex = temp.index;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return new ParseResult(currentIndex, 'term', ast.getSimplify());\r\n  }\r\n\r\n  findExpression(tokenIndex) {\r\n    const result = this.findTerm(tokenIndex);\r\n    let currentIndex = result.index;\r\n    const ast = new _term_ast_node__WEBPACK_IMPORTED_MODULE_2__.TermASTNode(result.ast);\r\n    while (true) {\r\n      if (this.tokens[currentIndex]?.content === '+') {\r\n        const temp = this.findTerm(currentIndex + 1);\r\n        ast.add('add', temp.ast);\r\n        currentIndex = temp.index;\r\n      } else if (this.tokens[currentIndex]?.content === '-') {\r\n        const temp = this.findTerm(currentIndex + 1);\r\n        ast.add('minus', temp.ast);\r\n        currentIndex = temp.index;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return new ParseResult(currentIndex, 'unaryExpression', ast.getSimplify());\r\n  }\r\n\r\n  findUnaryExpression(tokenIndex) {\r\n    const firstToken = this.tokens[tokenIndex];\r\n    let currentIndex = tokenIndex;\r\n    let ast;\r\n    if (firstToken?.content === '+') {\r\n      const temp = this.findUnaryExpression(tokenIndex + 1);\r\n      ast = new UnaryASTNode('positive', temp.ast);\r\n      currentIndex = temp.index;\r\n    } else if (firstToken?.content === '-') {\r\n      const temp = this.findUnaryExpression(tokenIndex + 1);\r\n      ast = new UnaryASTNode('negative', temp.ast);\r\n      currentIndex = temp.index;\r\n    } else {\r\n      const temp = this.findUnaryExpression(tokenIndex);\r\n      ast = temp.ast;\r\n      currentIndex = temp.index;\r\n    }\r\n    return new ParseResult(currentIndex, 'expression', ast);\r\n  }\r\n\r\n  parse() {\r\n    const tokenIndex = 0;\r\n    const result = this.findExpression(tokenIndex);\r\n    return result;\r\n  }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://mathematica/./src/parser.js?");

/***/ }),

/***/ "./src/term-ast-node.js":
/*!******************************!*\
  !*** ./src/term-ast-node.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TermASTNode\": () => (/* binding */ TermASTNode)\n/* harmony export */ });\n/* harmony import */ var _ast_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast-node */ \"./src/ast-node.js\");\n/* harmony import */ var _factor_ast_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./factor-ast-node */ \"./src/factor-ast-node.js\");\n/* harmony import */ var _integer_ast_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./integer-ast-node */ \"./src/integer-ast-node.js\");\n\r\n\r\n\r\n\r\nclass TermASTNode extends _ast_node__WEBPACK_IMPORTED_MODULE_0__.ASTNode {\r\n    constructor(value) {\r\n      super('term', []);\r\n      if (value) {\r\n        this.add('add', value);\r\n      }\r\n    }\r\n    add(type, value) {\r\n      this.child.push({ type, value });\r\n    }\r\n  \r\n    combine() {\r\n      const childStrMap = new Map();\r\n      this.child.forEach((term) => {\r\n        const str = term.value.toString();\r\n        const count = childStrMap.get(str);\r\n        if (count) {\r\n          childStrMap.set(str, count + 1);\r\n          if (term.type === 'add') {\r\n            childStrMap.set(str, count + 1);\r\n          } else {\r\n            childStrMap.set(str, count - 1);\r\n          }\r\n        } else {\r\n          if (term.type === 'add') {\r\n            childStrMap.set(str, 1);\r\n          } else {\r\n            childStrMap.set(str, -1);\r\n          }\r\n        }\r\n      });\r\n      const newChild = [];\r\n      this.child.forEach((term) => {\r\n        const str = term.value.toString();\r\n        const count = childStrMap.get(str);\r\n        if (count === 0) {\r\n          return;\r\n        }\r\n        if (count === 1) {\r\n          term.type = 'add';\r\n          newChild.push(term);\r\n        } else if (count === -1) {\r\n          term.type = 'minus';\r\n          newChild.push(term);\r\n        } else {\r\n          const result = new _factor_ast_node__WEBPACK_IMPORTED_MODULE_1__.FactorASTNode();\r\n          result.add('multiply', new _integer_ast_node__WEBPACK_IMPORTED_MODULE_2__.IntegerASTNode(count.toString()));\r\n          result.add('multiply', term.value);\r\n          term.value = result;\r\n          term.type = 'add';\r\n          newChild.push(term);\r\n        }\r\n        childStrMap.set(str, 0);\r\n      });\r\n      this.child = newChild;\r\n    }\r\n  \r\n    getSimplify() {\r\n      const addChild = this.child?.filter(child => child.value.type === 'term' && child.type === 'add');\r\n      this.child = this.child?.filter(child => child.value.type !== 'term' || child.type !== 'add');\r\n  \r\n      addChild.forEach((term) => {\r\n        term.value.child.forEach((child) => {\r\n          this.child.push(child);\r\n        });\r\n      });\r\n  \r\n      this.child = this.child?.filter((child) => {\r\n        if (child.value.type === 'integer') {\r\n          return !child.value?.value?.isZero();\r\n        }\r\n        return true;\r\n      });\r\n  \r\n      this.combine();\r\n  \r\n      if (this.child.length === 1) {\r\n        return this.child[0].value;\r\n      }\r\n      if (this.child.length === 0) {\r\n        return new _integer_ast_node__WEBPACK_IMPORTED_MODULE_2__.IntegerASTNode('0').compute();\r\n      }\r\n  \r\n      this.child.forEach((child) => {\r\n        if (child.value.type === 'positive') {\r\n          child.value = child.value.child;\r\n        } else if (child.value.type === 'negative') {\r\n          child.value = child.value.child;\r\n          if (child.type === 'add') {\r\n            child.type = 'minus';\r\n          } else {\r\n            child.type = 'add';\r\n          }\r\n        }\r\n      });\r\n      return this;\r\n    }\r\n    compute() {\r\n      this.getSimplify();\r\n      const ret = new TermASTNode();\r\n      const addList = this.child.filter(x => x.type === 'add').map(x => x.value.compute());\r\n      const minusList = this.child.filter(x => x.type === 'minus').map(x => x.value.compute());\r\n  \r\n      const incomputableMinusList = minusList.filter(x => x.type !== 'integer');\r\n      const integerMinus = minusList.filter(x => x.type === 'integer').reduce((x, y) => {\r\n        const result = x.value.add(y.value);\r\n        const _ret = new _integer_ast_node__WEBPACK_IMPORTED_MODULE_2__.IntegerASTNode(result.toString());\r\n        _ret.value = result;\r\n        return _ret;\r\n      }, new _integer_ast_node__WEBPACK_IMPORTED_MODULE_2__.IntegerASTNode('0').compute());\r\n  \r\n      integerMinus.value.positive = !integerMinus.value.positive;\r\n  \r\n      const incomputableAddList = addList.filter(x => x.type !== 'integer');\r\n      const integerAdd = addList.filter(x => x.type === 'integer').reduce((x, y) => {\r\n        const result = x.value.add(y.value);\r\n        const _ret = new _integer_ast_node__WEBPACK_IMPORTED_MODULE_2__.IntegerASTNode(result.toString());\r\n        _ret.value = result;\r\n        return _ret;\r\n      }, integerMinus);\r\n  \r\n  \r\n      if (integerAdd.value.positive === true) {\r\n        ret.add('add', integerAdd);\r\n      } else {\r\n        integerAdd.value.positive = true;\r\n        ret.add('minus', integerAdd);\r\n      }\r\n      incomputableAddList.forEach((x) => {\r\n        for (const element of x.symbols) {\r\n          ret.symbols.add(element);\r\n        }\r\n        ret.add('add', x);\r\n      });\r\n  \r\n      incomputableMinusList.forEach((x) => {\r\n        for (const element of x.symbols) {\r\n          ret.symbols.add(element);\r\n        }\r\n        ret.add('minus', x);\r\n      });\r\n      return ret.getSimplify();\r\n    }\r\n    toString() {\r\n      if (this.strRaw) {\r\n        return this.strRaw;\r\n      }\r\n      let result = this.child[0].value.toString();\r\n      if (this.child[0].type === 'minus') {\r\n        result = `-${result}`;\r\n      }\r\n      for (let i = 1; i < this.child.length; i++) {\r\n        const another = this.child[i].value.toString();\r\n        switch (this.child[i].type) {\r\n          case 'add':\r\n            result += ` + ${another}`;\r\n            break;\r\n          case 'minus':\r\n            result += ` - ${another}`;\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      }\r\n      this.strRaw = `(${result})`;\r\n      return this.strRaw;\r\n    }\r\n    clone() {\r\n      const ret = new TermASTNode();\r\n      for (let i = 0; i < this.child.length; i++) {\r\n        ret.add(this.child[i].type, this.child[i].value.clone());\r\n      }\r\n      return ret;\r\n    }\r\n    derivative(symbol) {\r\n      const ret = this.clone();\r\n      ret.child = ret.child.map((x) => {\r\n        x.value = x.value.derivative(symbol);\r\n        return x;\r\n      });\r\n      return ret.getSimplify();\r\n    }\r\n  }\n\n//# sourceURL=webpack://mathematica/./src/term-ast-node.js?");

/***/ }),

/***/ "./src/unary-ast-node.js":
/*!*******************************!*\
  !*** ./src/unary-ast-node.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UnaryASTNode\": () => (/* binding */ UnaryASTNode)\n/* harmony export */ });\n/* harmony import */ var _ast_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast-node */ \"./src/ast-node.js\");\n\r\n\r\n\r\nclass UnaryASTNode extends _ast_node__WEBPACK_IMPORTED_MODULE_0__.ASTNode {\r\n    constructor(type, child) {\r\n      super(type, child, null);\r\n    }\r\n    getSimplify() {\r\n      if (this.type === 'positive') {\r\n        return this.child;\r\n      }\r\n      if (this.child.type === 'negative') {\r\n        return this.child.child;\r\n      }\r\n      return this;\r\n    }\r\n  \r\n    compute() {\r\n      const temp = this.child.compute();\r\n      const ret = new UnaryASTNode(this.type, temp);\r\n      for (const element of temp.symbols) {\r\n        ret.symbols.add(element);\r\n      }\r\n      return ret.getSimplify();\r\n    }\r\n    toString() {\r\n      if (this.strRaw) {\r\n        return this.strRaw;\r\n      }\r\n      const temp = this.child.toString();\r\n      if (this.type === 'positive') {\r\n        this.strRaw = `+${temp}`;\r\n      } else if (this.type === 'negative') {\r\n        this.strRaw = `(-${temp})`;\r\n      }\r\n      return this.strRaw;\r\n    }\r\n    clone() {\r\n      return new UnaryASTNode(this.type, this.child.clone());\r\n    }\r\n    derivative(symbol) {\r\n      return new UnaryASTNode(this.type, this.child.derivative(symbol));\r\n    }\r\n  }\n\n//# sourceURL=webpack://mathematica/./src/unary-ast-node.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});