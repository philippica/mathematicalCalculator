!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.mathematica=t():e.mathematica=t()}(this,(function(){return(()=>{"use strict";var e={d:(t,i)=>{for(var s in i)e.o(i,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:i[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Lexical:()=>d});class i{constructor(e,t,i){this.symbols=new Set,this.child=t,this.value=i,this.type=e}}class s{static _base=10;static compressDegree=4;static realBase=this._base**this.compressDegree;constructor(e){this.rawDec=[],this.decimal=[],this.positive=!0,e&&this.parse(e)}clone(){const e=new s(this.rawDec);return e.positive=this.positive,e}parseNumber(e){e<0&&(this.positive=!1,e=-e);let t=e;for(this.rawDec=[];0!==t;)this.rawDec.push(t%s.realBase),t=parseInt(t/s.realBase,s._base)}parseString(e){"-"===e[0]&&(e=e.slice(1),this.positive=!1);const t=this.trimLeadingZero(e).split(".");this.rawDec=[];let i=t[0].length-1,n=0;for(;i>=0;){this.rawDec.push(0),n=this.rawDec.length-1;for(let e=s.compressDegree-1;e>=0;e--)this.rawDec[n]=this.rawDec[n]*s._base+parseInt(t[0][i-e]??0,s._base);i-=s.compressDegree}}parse(e){if(Array.isArray(e))this.rawDec=e;else switch(typeof e){case"number":this.parseNumber(e),this.positive=e>0;break;case"string":this.parseString(e)}}trimLeadingZero(e){return e.replace(/^0+/,"")}toString(){if(this.isZero())return"0";const e=this.rawDec.slice(0);let t="";for(;e.length>0;){let i=e.pop(),n="";for(let e=0;e<s.compressDegree;e++)n=(i%s._base).toString()+n,i=parseInt(i/s._base,s._base);t+=n}return t=this.trimLeadingZero(t),!1===this.positive&&(t=`-${t}`),t}inverse(){const e=new s(this.rawDec);return e.positive=!this.positive,e}linearOp(e,t,i,n){let r=0,o=this.rawDec,a=e.rawDec;const c=[];if(n){const e=o;o=a,a=e}for(let e=0;e<o.length||e<a.length;e++){const n=o[e]??0,h=a[e]??0,l=(t(n,h,r)+s.realBase)%s.realBase;c.push(l),r=i(t(n,h,r))}for(c.push(r);0===c[c.length-1]&&c.length>1;)c.pop();return new s(c)}add(e){let t=e;return"number"!=typeof e&&"string"!=typeof e||(t=new s(e)),this.positive&&t.positive?this.linearOp(t,((e,t,i)=>e+t+i),(e=>e>=s.realBase?1:0)):this.positive||t.positive?this.positive?this.minus(t.inverse()):t.minus(this.inverse()):this.linearOp(t,((e,t,i)=>e+t+i),(e=>e>=s.realBase?1:0)).inverse()}isZero(){for(const e of this.rawDec)if(0!==e)return!1;return!0}minus(e){let t=e;if("number"!=typeof e&&"string"!=typeof e||(t=new s(e)),!this.positive&&!t.positive)return t.inverse().minus(this);if(!this.positive&&t.positive)return this.inverse().add(t).inverse();if(this.positive&&!t.positive)return this.add(t.inverse());const i=!this.largerThan(e),n=this.linearOp(t,((e,t,i)=>e-t-i),(e=>e<0?1:0),i);for(i&&(n.positive=!1);0===n.rawDec[n.rawDec.length-1]&&n.rawDec.length>1;)n.rawDec.pop();return n}multiply(e){let t=e;"number"!=typeof e&&"string"!=typeof e||(t=new s(e));const i=[];for(let e=0;e<t.rawDec.length;e++)for(let n=0;n<this.rawDec.length;n++){void 0===i[e+n]&&i.push(0);const r=i[e+n]+t.rawDec[e]*this.rawDec[n];i[e+n]=r%s.realBase;const o=parseInt(r/s.realBase,10);o&&(void 0===i[e+n+1]&&i.push(0),i[e+n+1]+=o)}const n=new s(i);return n.positive=!(this.positive^t.positive),n}divide(e){let t=e;"number"!=typeof e&&"string"!=typeof e||(t=new s(e));const i=this.rawDec.length-t.rawDec.length;if(i<0)return new s(0);let n=new s(this.rawDec.slice(i)),r="";for(let t=i;t>=0;t--){let i=0;for(;;){const t=n.minus(e);if(!t.positive&&!t.isZero())break;i++,n=t}let o=i.toString();for(;o.length<s.compressDegree;)o=`0${o}`;for(r+=o,n.rawDec.unshift(0),t>0&&(n.rawDec[0]=this.rawDec[t-1]);0===n.rawDec[n.rawDec.length-1]&&n.rawDec.length>1;)n.rawDec.pop();n.positive=!0}const o=new s(r);return o.positive=!(this.positive^t.positive),o}largerThan(e){let t=e;for("number"!=typeof e&&"string"!=typeof e||(t=new s(e));0===t.rawDec[t.rawDec.length-1]&&t.rawDec.length>1;)t.rawDec.pop();for(;0===this.rawDec[this.rawDec.length-1]&&this.rawDec.length>1;)this.rawDec.pop();if(t.rawDec.length!==this.rawDec.length)return this.rawDec.length>t.rawDec.length;for(let e=t.rawDec.length-1;e>=0;e--)if(this.rawDec[e]!==t.rawDec[e])return this.rawDec[e]>t.rawDec[e];return!1}isEqual(e){let t=e;for("number"!=typeof e&&"string"!=typeof e||(t=new s(e));0===t.rawDec[t.rawDec.length-1]&&t.rawDec.length>1;)t.rawDec.pop();for(;0===this.rawDec[this.rawDec.length-1]&&this.rawDec.length>1;)this.rawDec.pop();if(t.rawDec.length!==this.rawDec.length)return!1;for(let e=t.rawDec.length-1;e>=0;e--)if(this.rawDec[e]!==t.rawDec[e])return!1;return t.positive===this.positive}}class n extends i{constructor(e){super("integer",null),e.rawDec&&(this.obj=e.toString(),this.value=e),this.obj=e}compute(){const e=this.clone();return e.value=this.value??new s(this.obj),e}toString(){return this.obj}clone(){return new n(this.obj)}derivative(){return new n("0")}}class r extends i{constructor(e,t){super("Exponent",null),this.base=e,this.power=t}add(e){this.power=e}getSimplify(){return this.power?"integer"===this.power.type&&"1"===this.power?.obj?this.base:this:this.base}quickPower(e,t){if(t.isZero())return new s(1);if(1&t.rawDec[0])return e.multiply(this.quickPower(e,t.minus(1)));const i=this.quickPower(e,t.divide(2));return i.multiply(i)}compute(){const e=this.base.compute(),t=this.power.compute();if("integer"===e.type&&"integer"===t.type){let i=new s(1);return t.value.positive&&(i=this.quickPower(e.value,t.value)),new n(i.toString())}const i=new r(e,t).getSimplify();for(const t of e.symbols)i.symbols.add(t);for(const e of t.symbols)i.symbols.add(e);return i}toString(){if(this.strRaw)return this.strRaw;const e=this.base.toString(),t=this.power.toString();return this.strRaw=`${e} ^ ${t}`,this.strRaw}clone(){return new r(this.base,this.power)}derivative(e){if(!this.power.symbols.has(e)){const e=new a;e.add("multiply",this.power.clone());const t=new c(this.power.clone());return t.add("minus",new n("1")),e.add("multiply",new r(this.base,t)),e}}}class o extends i{constructor(e,t){super(e,t,null)}getSimplify(){return"positive"===this.type?this.child:"negative"===this.child.type?this.child.child:this}compute(){const e=this.child.compute(),t=new o(this.type,e);for(const i of e.symbols)t.symbols.add(i);return t.getSimplify()}toString(){if(this.strRaw)return this.strRaw;const e=this.child.toString();return"positive"===this.type?this.strRaw=`+${e}`:"negative"===this.type&&(this.strRaw=`(-${e})`),this.strRaw}clone(){return new o(this.type,this.child.clone())}derivative(e){return new o(this.type,this.child.derivative(e))}}class a extends i{constructor(e){super("factor",[]),e&&this.add("multiply",e)}add(e,t){this.child.push({type:e,value:t})}combine(){const e=new Map;this.child.forEach((t=>{let i=t.value.toString(),n=new s(1);"Exponent"===t.value.type&&"integer"===t.value.power.type&&(i=t.value.base.toString(),n=t.value.power.compute().value);const r=e.get(i);r?(e.set(i,r.add(n)),"multiply"===t.type?e.set(i,r.add(n)):e.set(i,r.minus(n))):"multiply"===t.type?e.set(i,n):e.set(i,n.inverse())}));const t=[];this.child.forEach((i=>{let o=i.value.toString(),a=i.value;"Exponent"===i.value.type&&"integer"===i.value.power.type&&(o=i.value.base.toString(),a=i.value.base);const c=e.get(o);if(!c.isZero()){if(c.isEqual(1))i.type="multiply",t.push(i);else if(c.isEqual(-1))i.type="divide",t.push(i);else{const e=new r(a);e.add(new n(c.toString())),i.value=e,i.type="multiply",t.push(i)}e.set(o,new s(0))}})),this.child=t}getSimplify(){const e=this.child?.filter((e=>"factor"===e.value.type&&"multiply"===e.type));this.child=this.child?.filter((e=>"factor"!==e.value.type||"multiply"!==e.type)),e.forEach((e=>{e.value.child.forEach((e=>{this.child.push(e)}))})),this.child=this.child?.filter((e=>"integer"!==e.value.type||"1"!==e.value?.obj));const t=this.child?.filter((e=>"integer"===e.value.type&&"0"===e.value?.obj));if(t.length>0)return new n("0").compute();if(0===this.child.length)return new n("1").compute();if(this.combine(),1===this.child.length&&"multiply"===this.child[0].type)return this.child[0].value;if(0===this.child.length)return new n("1").compute();let i=0;return this.child?.forEach((e=>{"negative"===e.value.type?(e.value=e.value.child,i++):"positive"===e.value.type&&(e.value=e.value.child)})),1&i?new o("negative",this):this}compute(){const e=new a,t=this.child.filter((e=>"multiply"===e.type)).map((e=>e.value.compute())),i=this.child.filter((e=>"divide"===e.type)).map((e=>e.value.compute())),s=t.filter((e=>"integer"!==e.type)),r=t.filter((e=>"integer"===e.type)).reduce(((e,t)=>{const i=e.value.multiply(t.value),s=new n(i.toString());return s.value=i,s}),new n("1").compute()),o=i.filter((e=>"integer"!==e.type)),c=i.filter((e=>"integer"===e.type)).reduce(((e,t)=>{const i=e.value.multiply(t.value),s=new n(i.toString());return s.value=i,s}),new n("1").compute());return e.add("multiply",r),s.forEach((t=>{for(const i of t.symbols)e.symbols.add(i);e.add("multiply",t)})),e.add("divide",c),o.forEach((t=>{for(const i of t.symbols)e.symbols.add(i);e.add("divide",t)})),e.getSimplify()}derivative(e){const t=new c;for(let i=0;i<this.child.length;i++){const s=this.clone();s.child[i].value=s.child[i].value.derivative(e),t.add("add",s)}return t.getSimplify()}clone(){const e=new a;for(let t=0;t<this.child.length;t++)e.add(this.child[t].type,this.child[t].value.clone());return e}toString(){if(this.strRaw)return this.strRaw;let e=this.child[0].value.toString(),t="multiply"===this.child[0].type;for(let i=1;i<this.child.length;i++){const s=this.child[i].value.toString();switch(this.child[i].type){case"multiply":e+=` * ${s}`,t=1;break;case"divide":e+=` / ${s}`}}return 0===t&&(e=`(1 / ${e})`),this.strRaw=e,this.strRaw}}class c extends i{constructor(e){super("term",[]),e&&this.add("add",e)}add(e,t){this.child.push({type:e,value:t})}combine(){const e=new Map;this.child.forEach((t=>{const i=t.value.toString(),s=e.get(i);s?(e.set(i,s+1),"add"===t.type?e.set(i,s+1):e.set(i,s-1)):"add"===t.type?e.set(i,1):e.set(i,-1)}));const t=[];this.child.forEach((i=>{const s=i.value.toString(),r=e.get(s);if(0!==r){if(1===r)i.type="add",t.push(i);else if(-1===r)i.type="minus",t.push(i);else{const e=new a;e.add("multiply",new n(r.toString())),e.add("multiply",i.value),i.value=e,i.type="add",t.push(i)}e.set(s,0)}})),this.child=t}getSimplify(){const e=this.child?.filter((e=>"term"===e.value.type&&"add"===e.type));return this.child=this.child?.filter((e=>"term"!==e.value.type||"add"!==e.type)),e.forEach((e=>{e.value.child.forEach((e=>{this.child.push(e)}))})),this.child=this.child?.filter((e=>"integer"!==e.value.type||!e.value?.value?.isZero())),this.combine(),1===this.child.length?this.child[0].value:0===this.child.length?new n("0").compute():(this.child.forEach((e=>{"positive"===e.value.type?e.value=e.value.child:"negative"===e.value.type&&(e.value=e.value.child,"add"===e.type?e.type="minus":e.type="add")})),this)}compute(){this.getSimplify();const e=new c,t=this.child.filter((e=>"add"===e.type)).map((e=>e.value.compute())),i=this.child.filter((e=>"minus"===e.type)).map((e=>e.value.compute())),s=i.filter((e=>"integer"!==e.type)),r=i.filter((e=>"integer"===e.type)).reduce(((e,t)=>{const i=e.value.add(t.value),s=new n(i.toString());return s.value=i,s}),new n("0").compute());r.value.positive=!r.value.positive;const o=t.filter((e=>"integer"!==e.type)),a=t.filter((e=>"integer"===e.type)).reduce(((e,t)=>{const i=e.value.add(t.value),s=new n(i.toString());return s.value=i,s}),r);return!0===a.value.positive?e.add("add",a):(a.value.positive=!0,e.add("minus",a)),o.forEach((t=>{for(const i of t.symbols)e.symbols.add(i);e.add("add",t)})),s.forEach((t=>{for(const i of t.symbols)e.symbols.add(i);e.add("minus",t)})),e.getSimplify()}toString(){if(this.strRaw)return this.strRaw;let e=this.child[0].value.toString();"minus"===this.child[0].type&&(e=`-${e}`);for(let t=1;t<this.child.length;t++){const i=this.child[t].value.toString();switch(this.child[t].type){case"add":e+=` + ${i}`;break;case"minus":e+=` - ${i}`}}return this.strRaw=`(${e})`,this.strRaw}clone(){const e=new c;for(let t=0;t<this.child.length;t++)e.add(this.child[t].type,this.child[t].value.clone());return e}derivative(e){const t=this.clone();return t.child=t.child.map((t=>(t.value=t.value.derivative(e),t))),t.getSimplify()}}class h extends i{constructor(e,t){super("function"),this.parameter=t,this.functionName=e}compute(){const e=this.clone();return e.parameter=e.parameter.compute(),e}clone(){return new h(this.functionName,this.parameter.clone())}toString(){let e;return e="term"===this.parameter.type?`${this.functionName}${this.parameter.toString()}`:`${this.functionName}(${this.parameter.toString()})`,e}functionDerivativeProcess(e){let t;switch(e.functionName){case"sin":e.functionName="cos",t=e;break;case"exp":e.functionName="exp",t=e;break;case"cos":e.functionName="sin",t=new o("negative",e);break;case"ln":t=new a(new n("1")),t.add("divide",e.parameter);break;default:e.functionName=`${e.functionName}'`,t=e}return t}derivative(e){const t=this.functionDerivativeProcess(this.clone()),i=new a(t);return i.add("multiply",this.parameter.derivative(e)),i}}class l extends i{constructor(e){super("symbol"),this.symbolName=e,this.symbols.add(e)}compute(){return this.clone()}toString(){return this.symbolName}clone(){return new l(this.symbolName)}derivative(e){let t;return t=this.symbolName===e?new n("1"):new n("0"),t}}class u{constructor(e,t){this.type=e,this.content=t}}class p{constructor(e,t,i,s){this.index=e,this.type=t,this.ast=i,this.value=s}}class d{constructor(e){this.symbols=new Set,this.tokens=[],e&&this.generateTokens(e)}setSym(e){this.symbols.add(e)}singleCharacterProcess(e){switch(e){case"+":case"-":case"*":case"/":return this.tokens.push(new u("sign",e)),0;case"(":case")":return this.tokens.push(new u("parentheses",e)),0;case"\t":case"\n":case" ":return 0}}vacantProcess(e){switch(e){case"+":case"-":case"*":case"/":case"^":case"=":return this.tokens.push(new u("sign",e)),0;case"(":case")":return this.tokens.push(new u("parentheses",e)),0;case"\t":case"\n":case" ":return 0}return/^[_a-zA-Z|\/|\\]$/.test(e)?(this.tokens.push(new u("function",e)),1):/^[0-9]$/.test(e)?(this.tokens.push(new u("integer",e)),2):void 0}receiveFuncProcess(e){if(/^[_0-9a-zA-Z|\\]$/.test(e)){const t=this.tokens.pop();return t.content+=e,this.tokens.push(t),1}return this.vacantProcess(e)}receiveIntegerProcess(e){if(/^[0-9]$/.test(e)){const t=this.tokens.pop();return t.content+=e,this.tokens.push(t),2}return this.vacantProcess(e)}generateTokens(e){let t=0;for(const i of e)switch(t){case 0:t=this.vacantProcess(i);break;case 1:t=this.receiveFuncProcess(i);break;case 2:t=this.receiveIntegerProcess(i)}for(const e of this.tokens)"function"===e.type&&this.symbols.has(e.content)&&(e.type="symbol");return this.tokens}findPower(e){let t=e;const i=this.tokens[t];if("("===i?.content){const e=this.findExpression(t+1);if(t=e.index,")"!==this.tokens[t]?.content)throw Error("parentheses is not match");return new p(t+1,"expression",e.ast)}if("integer"===i.type)return new p(t+1,i.type,new n(i.content));if("symbol"===i.type)return new p(t+1,i.type,new l(i.content));if("function"===i.type&&"("===this.tokens[t+1].content){const e=this.findExpression(t+2);if(t=e.index,")"!==this.tokens[t]?.content)throw Error("parentheses is not match");const s={};return s.functionName=i.content,s.parameter=e.ast,new p(t+1,i.type,new h(i.content,e.ast))}if("+"===i?.content){const i=this.findTerm(e+1),s=new UnaryASTNode("positive",i.ast);return t=i.index,new p(t,"expression",s)}if("-"===i?.content){const i=this.findTerm(e+1),s=new UnaryASTNode("negative",i.ast);return t=i.index,new p(t,"expression",s)}}findFactor(e){const t=this.findPower(e);let i=t.index;const s=new r(t.ast);if("^"===this.tokens[i]?.content){const e=this.findPower(i+1);s.add(e.ast),i=e.index}return new p(i,"term",s.getSimplify())}findTerm(e){const t=this.findFactor(e);let i=t.index;const s=new a(t.ast);for(;;)if("*"===this.tokens[i]?.content){const e=this.findFactor(i+1);s.add("multiply",e.ast),i=e.index}else{if("/"!==this.tokens[i]?.content)break;{const e=this.findFactor(i+1);s.add("divide",e.ast),i=e.index}}return new p(i,"term",s.getSimplify())}findExpression(e){const t=this.findTerm(e);let i=t.index;const s=new c(t.ast);for(;;)if("+"===this.tokens[i]?.content){const e=this.findTerm(i+1);s.add("add",e.ast),i=e.index}else{if("-"!==this.tokens[i]?.content)break;{const e=this.findTerm(i+1);s.add("minus",e.ast),i=e.index}}return new p(i,"unaryExpression",s.getSimplify())}findUnaryExpression(e){const t=this.tokens[e];let i,s=e;if("+"===t?.content){const t=this.findUnaryExpression(e+1);i=new UnaryASTNode("positive",t.ast),s=t.index}else if("-"===t?.content){const t=this.findUnaryExpression(e+1);i=new UnaryASTNode("negative",t.ast),s=t.index}else{const t=this.findUnaryExpression(e);i=t.ast,s=t.index}return new p(s,"expression",i)}parse(){return this.findExpression(0)}}return t})()}));