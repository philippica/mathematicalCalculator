!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.mathematica=t():e.mathematica=t()}(this,(function(){return(()=>{"use strict";var e={d:(t,i)=>{for(var s in i)e.o(i,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:i[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Lexical:()=>d});class i{constructor(e,t,i){this.symbols=new Set,this.child=t,this.value=i,this.type=e}}class s{static _base=10;static compressDegree=4;static realBase=this._base**this.compressDegree;constructor(e){this.rawDec=[],this.decimal=[],this.positive=!0,e&&this.parse(e)}clone(){const e=new s(this.rawDec);return e.positive=this.positive,e}parseNumber(e){e<0&&(this.positive=!1,e=-e);let t=e;for(this.rawDec=[];0!==t;)this.rawDec.push(t%s.realBase),t=parseInt(t/s.realBase,s._base)}parseString(e){"-"===e[0]&&(e=e.slice(1),this.positive=!1);const t=this.trimLeadingZero(e);let i;for(i=0;i<t.length&&"."!==t[i];i++);const n=[t.slice(0,i)];this.rawDec=[];let r=n[0].length-1,o=0;const a=n[0];for(;r>=0;){this.rawDec.push(0),o=this.rawDec.length-1;const e=s.compressDegree,t=s._base;let n=0;for(i=e-1;i>=0;i--)n=n*t+parseInt(a[r-i]??0,t);this.rawDec[o]=n,r-=e}}parse(e){if(Array.isArray(e))this.rawDec=e;else switch(typeof e){case"number":this.parseNumber(e),this.positive=e>0;break;case"string":this.parseString(e)}}trimLeadingZero(e){let t=0;for(;"0"===e[t];)t++;return""===e.slice(t)?"0":e.slice(t)}toString(){if(this.isZero())return"0";const e=this.rawDec.slice(0);let t="";for(;e.length>0;){let i=e.pop(),n="";for(let e=0;e<s.compressDegree;e++)n=(i%s._base).toString()+n,i=parseInt(i/s._base,s._base);t+=n}return t=this.trimLeadingZero(t),!1===this.positive&&(t=`-${t}`),t}inverse(){const e=new s(this.rawDec);return e.positive=!this.positive,e}linearOp(e,t,i,n){const r=s.realBase;let o=0,a=this.rawDec,c=e.rawDec;const l=[];if(n){const e=a;a=c,c=e}for(let e=0;e<a.length||e<c.length;e++){const s=a[e]??0,n=c[e]??0,h=(t(s,n,o)+r)%r;l.push(h),o=i(t(s,n,o))}for(l.push(o);0===l[l.length-1]&&l.length>1;)l.pop();return new s(l)}add(e){let t=e;return"number"!=typeof e&&"string"!=typeof e||(t=new s(e)),this.positive&&t.positive?this.linearOp(t,((e,t,i)=>e+t+i),(e=>e>=s.realBase?1:0)):this.positive||t.positive?this.positive?this.minus(t.inverse()):t.minus(this.inverse()):this.linearOp(t,((e,t,i)=>e+t+i),(e=>e>=s.realBase?1:0)).inverse()}isZero(){for(const e of this.rawDec)if(0!==e)return!1;return!0}minus(e){let t=e;if("number"!=typeof e&&"string"!=typeof e||(t=new s(e)),!this.positive&&!t.positive)return t.inverse().minus(this);if(!this.positive&&t.positive)return this.inverse().add(t).inverse();if(this.positive&&!t.positive)return this.add(t.inverse());const i=!this.largerThan(t),n=this.linearOp(t,((e,t,i)=>e-t-i),(e=>e<0?1:0),i);for(i&&(n.positive=!1);0===n.rawDec[n.rawDec.length-1]&&n.rawDec.length>1;)n.rawDec.pop();return n}multiply(e){let t=e;"number"!=typeof e&&"string"!=typeof e||(t=new s(e));const i=s.realBase,n=[];for(let e=0;e<t.rawDec.length;e++)for(let s=0;s<this.rawDec.length;s++){void 0===n[e+s]&&n.push(0);const r=n[e+s]+t.rawDec[e]*this.rawDec[s];n[e+s]=r%i;const o=parseInt(r/i,10);o&&(void 0===n[e+s+1]&&n.push(0),n[e+s+1]+=o)}const r=new s(n);return r.positive=!(this.positive^t.positive),r}divide(e){const t=(e,t,i)=>{let s=0;for(;;){const n=i.minus(e);if(!n.positive&&!n.isZero())break;s+=t,i=n}return[s,i]};let i=e;"number"!=typeof e&&"string"!=typeof e||(i=new s(e));const n=this.rawDec.length-i.rawDec.length;if(n<0)return new s(0);let r=new s(this.rawDec.slice(n)),o="";const a=new s;a.rawDec.push(1e3);const c=new s;c.rawDec.push(100);const l=new s;l.rawDec.push(10);for(let e=n;e>=0;e--){let n=0,[h,p]=t(i.multiply(a),1e3,r);n+=h,r=p,[h,p]=t(i.multiply(c),100,r),n+=h,r=p,[h,p]=t(i.multiply(l),10,r),n+=h,r=p,[h,p]=t(i,1,r),n+=h,r=p;let u=n.toString();for(;u.length<s.compressDegree;)u=`0${u}`;for(o+=u,r.rawDec.unshift(0),e>0&&(r.rawDec[0]=this.rawDec[e-1]);0===r.rawDec[r.rawDec.length-1]&&r.rawDec.length>1;)r.rawDec.pop();r.positive=!0}const h=new s(o);return h.positive=!(this.positive^i.positive),h}largerThan(e){let t=e;for("number"!=typeof e&&"string"!=typeof e||(t=new s(e));0===t.rawDec[t.rawDec.length-1]&&t.rawDec.length>1;)t.rawDec.pop();for(;0===this.rawDec[this.rawDec.length-1]&&this.rawDec.length>1;)this.rawDec.pop();if(t.rawDec.length!==this.rawDec.length)return this.rawDec.length>t.rawDec.length;for(let e=t.rawDec.length-1;e>=0;e--)if(this.rawDec[e]!==t.rawDec[e])return this.rawDec[e]>t.rawDec[e];return!1}isEqual(e){let t=e;for("number"!=typeof e&&"string"!=typeof e||(t=new s(e));0===t.rawDec[t.rawDec.length-1]&&t.rawDec.length>1;)t.rawDec.pop();for(;0===this.rawDec[this.rawDec.length-1]&&this.rawDec.length>1;)this.rawDec.pop();if(t.rawDec.length!==this.rawDec.length)return!1;for(let e=t.rawDec.length-1;e>=0;e--)if(this.rawDec[e]!==t.rawDec[e])return!1;return t.positive===this.positive}}class n extends i{constructor(e){super("integer",null),e.rawDec&&(this.obj=e.toString(),this.value=e),this.obj=e}compute(){const e=this.clone();return e.value=this.value??new s(this.obj),e}toString(){return this.value||(this.value=new s(this.obj)),!1!==this.value.positive||this.value.isZero()?this.obj:`(${this.obj})`}clone(){return new n(this.obj)}derivative(){return new n("0")}}class r extends i{constructor(e,t){super(e,t,null)}getSimplify(){return"positive"===this.type?this.child:"negative"===this.child.type?this.child.child:this}compute(){let e=this.child.compute();if("integer"===e.type)return e=e.compute(),"negative"===this.type&&(e.value.positive=!e.value.positive,e.obj=e.value.toString()),e;const t=new r(this.type,e);for(const i of e.symbols)t.symbols.add(i);return t.getSimplify()}toString(){if(this.strRaw)return this.strRaw;const e=this.child.toString();return"positive"===this.type?this.strRaw=`+${e}`:"negative"===this.type&&(this.strRaw=`(-${e})`),this.strRaw}clone(){return new r(this.type,this.child.clone())}derivative(e){return new r(this.type,this.child.derivative(e))}}class o extends i{constructor(e,t){super("function"),this.parameter=t,this.functionName=e}getSimplify(){let e=this;switch(this.functionName){case"sin":"negative"===this.parameter.type&&(e=new o("sin",this.parameter.child),e.symbols=this.symbols,e=new r("negative",e),e.symbols=this.symbols);break;case"exp":break;case"cos":"negative"===this.parameter.type&&(this.parameter=this.parameter.child);break;case"ln":if("Exponent"===this.parameter.type){e=new c(this.parameter.power);const t=new o("ln",this.parameter.base);e.add("multiply",t)}}return e}compute(){const e=this.clone();e.parameter=e.parameter.compute();for(const t of this.parameter.symbols)e.symbols.add(t);return e.getSimplify()}clone(){return new o(this.functionName,this.parameter.clone())}toString(){let e;return e="term"===this.parameter.type||"negative"===this.parameter.type?`${this.functionName}${this.parameter.toString()}`:`${this.functionName}(${this.parameter.toString()})`,e}functionDerivativeProcess(e){let t;switch(e.functionName){case"sin":e.functionName="cos",t=e;break;case"exp":e.functionName="exp",t=e;break;case"cos":e.functionName="sin",t=new r("negative",e);break;case"ln":t=new c(new n("1")),t.add("divide",e.parameter);break;default:e.functionName=`${e.functionName}'`,t=e}return t}derivative(e){const t=this.functionDerivativeProcess(this.clone()),i=new c(t);return i.add("multiply",this.parameter.derivative(e)),i}}class a extends i{constructor(e,t){super("Exponent",null),this.base=e,this.power=t}add(e){this.power=e}getSimplify(){return this.power?"integer"===this.power.type&&"1"===this.power?.obj?this.base:this:this.base}quickPower(e,t){if(t.isZero())return new s(1);if(1&t.rawDec[0])return e.multiply(this.quickPower(e,t.minus(1)));const i=this.quickPower(e,t.divide(2));return i.multiply(i)}compute(){const e=this.base.compute(),t=this.power.compute();if("integer"===e.type&&"integer"===t.type){let i=new s(1);return t.value.positive&&(i=this.quickPower(e.value,t.value)),new n(i.toString())}const i=new a(e,t).getSimplify();for(const t of e.symbols)i.symbols.add(t);for(const e of t.symbols)i.symbols.add(e);return i.getSimplify()}toString(){if(this.strRaw)return this.strRaw;let e=this.base.toString(),t=this.power.toString();return"Exponent"!==this.base.type&&"factor"!==this.base.type||(e=`(${e})`),"Exponent"!==this.power.type&&"factor"!==this.power.type||(t=`(${t})`),this.strRaw=`${e} ^ ${t}`,this.strRaw}clone(){return new a(this.base,this.power)}derivative(e){if(!this.base.symbols.has(e)&&!this.power.symbols.has(e))return new n("1");if(!this.power.symbols.has(e)){const e=new c;e.add("multiply",this.power.clone());const t=new l(this.power.clone());return t.add("minus",new n("1")),e.add("multiply",new a(this.base,t)),e}if(!this.base.symbols.has(e)){const e=new c;return e.add("multiply",this.power.derivative("x")),e.add("multiply",this.clone()),e.add("multiply",new o("ln",this.base.compute())),e}const t=new c(this.clone()),i=new c(this.power.clone());return i.add("multiply",new o("ln",this.base.compute())),t.add("multiply",i.derivative("x")),t.compute()}}class c extends i{constructor(e){super("factor",[]),e&&this.add("multiply",e)}add(e,t){this.child.push({type:e,value:t})}combine(){const e=new Map;this.child.forEach((t=>{let i=t.value.toString(),n=new s(1);"Exponent"===t.value.type&&"integer"===t.value.power.type&&(i=t.value.base.toString(),n=t.value.power.compute().value);const r=e.get(i);r?(e.set(i,r.add(n)),"multiply"===t.type?e.set(i,r.add(n)):e.set(i,r.minus(n))):"multiply"===t.type?e.set(i,n):e.set(i,n.inverse())}));const t=[];this.child.forEach((i=>{let r=i.value.toString(),o=i.value;"Exponent"===i.value.type&&"integer"===i.value.power.type&&(r=i.value.base.toString(),o=i.value.base);const c=e.get(r);if(!c.isZero()){if(c.isEqual(1))t.push({type:"multiply",value:o});else if(c.isEqual(-1))t.push({type:"divide",value:o});else{const e=new a(o);e.add(new n(c.toString())),i.value=e,i.type="multiply",t.push(i)}e.set(r,new s(0))}})),this.child=t}getSimplify(){const e=this.child?.filter((e=>"factor"===e.value.type&&"multiply"===e.type));this.child=this.child?.filter((e=>"factor"!==e.value.type||"multiply"!==e.type)),e.forEach((e=>{e.value.child.forEach((e=>{this.child.push(e)}))})),this.child=this.child?.filter((e=>"integer"!==e.value.type||"1"!==e.value?.obj));const t=this.child?.filter((e=>"integer"===e.value.type&&"0"===e.value?.obj));if(t.length>0)return new n("0").compute();if(0===this.child.length)return new n("1").compute();if(this.combine(),1===this.child.length&&"multiply"===this.child[0].type)return this.child[0].value;if(0===this.child.length)return new n("1").compute();let i=0;return this.child?.forEach((e=>{"negative"===e.value.type?(e.value=e.value.child,i++):"positive"===e.value.type&&(e.value=e.value.child)})),this.child=this.child?.filter((e=>"integer"!==e.value.type||"1"!==e.value?.obj)),1&i?new r("negative",this):this}compute(){const e=new c,t=this.child.filter((e=>"multiply"===e.type)).map((e=>e.value.compute())),i=this.child.filter((e=>"divide"===e.type)).map((e=>e.value.compute())),s=t.filter((e=>"integer"!==e.type)),r=t.filter((e=>"integer"===e.type)).reduce(((e,t)=>{const i=e.value.multiply(t.value),s=new n(i.toString());return s.value=i,s}),new n("1").compute()),o=i.filter((e=>"integer"!==e.type)),a=i.filter((e=>"integer"===e.type)).reduce(((e,t)=>{const i=e.value.multiply(t.value),s=new n(i.toString());return s.value=i,s}),new n("1").compute());return e.add("multiply",r),s.forEach((t=>{for(const i of t.symbols)e.symbols.add(i);e.add("multiply",t)})),e.add("divide",a),o.forEach((t=>{for(const i of t.symbols)e.symbols.add(i);e.add("divide",t)})),e.getSimplify()}derivative(e){const t=this.child.filter((e=>"multiply"===e.type)).map((e=>e.value.compute())),i=this.child.filter((e=>"divide"===e.type)).map((e=>e.value.compute()));let s=new l,r=new c;if(t.forEach((e=>{r.add("multiply",e)})),r=r.compute(),"factor"!==r.type)s=r.derivative("x").compute();else for(let i=0;i<t.length;i++){const t=r.clone();t.child[i].value=t.child[i].value.derivative(e).compute(),s.add("add",t)}if(s=s.compute(),0===i.length)return s.compute();let o=new c;i.forEach((e=>{o.add("multiply",e)})),o=o.compute();const h=o.derivative(e).compute(),p=new c(s);p.add("multiply",o);const u=new c(h);u.add("multiply",r);const d=new l(p);d.add("minus",u);const f=new a(o.clone(),new n("2")),m=new c(d.compute());return m.add("divide",f.compute()),m.compute()}clone(){const e=new c;for(let t=0;t<this.child.length;t++)e.add(this.child[t].type,this.child[t].value.clone());return e}toString(){if(this.strRaw)return this.strRaw;const e=this.child.filter((e=>"multiply"===e.type)),t=this.child.filter((e=>"divide"===e.type));let i;if(0===e.length){i="1 / ";for(let e=0;e<t.length;e++)i+=` / ${t[e].value.toString()}`;return i}i=e[0].value.toString();for(let t=1;t<e.length;t++)i=`${i} * ${e[t].value.toString()}`;for(let e=0;e<t.length;e++)i=`${i} / ${t[e].value.toString()}`;return this.strRaw=i,this.strRaw}}class l extends i{constructor(e){super("term",[]),e&&this.add("add",e)}add(e,t){this.child.push({type:e,value:t})}combine(){const e=new Map;this.child.forEach((t=>{const i=t.value.toString(),s=e.get(i);s?(e.set(i,s+1),"add"===t.type?e.set(i,s+1):e.set(i,s-1)):"add"===t.type?e.set(i,1):e.set(i,-1)}));const t=[];this.child.forEach((i=>{const s=i.value.toString(),r=e.get(s);if(0!==r){if(1===r)i.type="add",t.push(i);else if(-1===r)i.type="minus",t.push(i);else{const e=new c;e.add("multiply",new n(r.toString())),e.add("multiply",i.value),i.value=e,i.type="add",t.push(i)}e.set(s,0)}})),this.child=t}getSimplify(){const e=this.child?.filter((e=>"term"===e.value.type&&"add"===e.type));return this.child=this.child?.filter((e=>"term"!==e.value.type||"add"!==e.type)),e.forEach((e=>{e.value.child.forEach((e=>{this.child.push(e)}))})),this.child=this.child?.filter((e=>"integer"!==e.value.type||!e.value?.value?.isZero())),this.combine(),1===this.child.length?"add"===this.child[0].type?this.child[0].value:new r("negative",this.child[0].value):0===this.child.length?new n("0").compute():(this.child.forEach((e=>{"positive"===e.value.type?e.value=e.value.child:"negative"===e.value.type&&(e.value=e.value.child,"add"===e.type?e.type="minus":e.type="add")})),this)}compute(){this.getSimplify();const e=new l,t=this.child.filter((e=>"add"===e.type)).map((e=>e.value.compute())),i=this.child.filter((e=>"minus"===e.type)).map((e=>e.value.compute())),s=i.filter((e=>"integer"!==e.type)),r=i.filter((e=>"integer"===e.type)).reduce(((e,t)=>{const i=e.value.add(t.compute().value),s=new n(i.toString());return s.value=i,s.compute()}),new n("0").compute());r.value.positive=!r.value.positive;const o=t.filter((e=>"integer"!==e.type)),a=t.filter((e=>"integer"===e.type)).reduce(((e,t)=>{const i=e.value.add(t.compute().value),s=new n(i.toString());return s.value=i,s.compute()}),r);return!0===a.value.positive?e.add("add",a):(a.value.positive=!0,a.obj=a.value.toString(),e.add("minus",a)),o.forEach((t=>{for(const i of t.symbols)e.symbols.add(i);e.add("add",t)})),s.forEach((t=>{for(const i of t.symbols)e.symbols.add(i);e.add("minus",t)})),e.getSimplify()}toString(){if(this.strRaw)return this.strRaw;let e=this.child[0].value.toString();"minus"===this.child[0].type&&(e=`-${e}`);for(let t=1;t<this.child.length;t++){const i=this.child[t].value.toString();switch(this.child[t].type){case"add":e+=` + ${i}`;break;case"minus":e+=` - ${i}`}}return this.strRaw=`(${e})`,this.strRaw}clone(){const e=new l;for(let t=0;t<this.child.length;t++)e.add(this.child[t].type,this.child[t].value.clone());return e}derivative(e){const t=this.clone();return t.child=t.child.map((t=>(t.value=t.value.derivative(e),t))),t.getSimplify()}}class h extends i{constructor(e){super("symbol"),this.symbolName=e,this.symbols.add(e)}compute(){return this.clone()}toString(){return this.symbolName}clone(){return new h(this.symbolName)}derivative(e){let t;return t=this.symbolName===e?new n("1"):new n("0"),t}}class p{constructor(e,t){this.type=e,this.content=t}}class u{constructor(e,t,i,s){this.index=e,this.type=t,this.ast=i,this.value=s}}class d{constructor(e){this.symbols=new Set,this.tokens=[],e&&this.generateTokens(e)}setSym(e){this.symbols.add(e)}singleCharacterProcess(e){switch(e){case"+":case"-":case"*":case"/":return this.tokens.push(new p("sign",e)),0;case"(":case")":return this.tokens.push(new p("parentheses",e)),0;case"\t":case"\n":case" ":return 0}}vacantProcess(e){switch(e){case"+":case"-":case"*":case"/":case"^":case"=":return this.tokens.push(new p("sign",e)),0;case"(":case")":return this.tokens.push(new p("parentheses",e)),0;case"\t":case"\n":case" ":return 0}return/^[_a-zA-Z|\/|\\]$/.test(e)?(this.tokens.push(new p("function",e)),1):/^[0-9]$/.test(e)?(this.tokens.push(new p("integer",e)),2):void 0}receiveFuncProcess(e){if(/^[_0-9a-zA-Z|\\]$/.test(e)){const t=this.tokens.pop();return t.content+=e,this.tokens.push(t),1}return this.vacantProcess(e)}receiveIntegerProcess(e){if(/^[0-9]$/.test(e)){const t=this.tokens.pop();return t.content+=e,this.tokens.push(t),2}return this.vacantProcess(e)}generateTokens(e){let t=0;for(const i of e)switch(t){case 0:t=this.vacantProcess(i);break;case 1:t=this.receiveFuncProcess(i);break;case 2:t=this.receiveIntegerProcess(i)}for(const e of this.tokens)"function"===e.type&&this.symbols.has(e.content)&&(e.type="symbol");return this.tokens}findPower(e){let t=e;const i=this.tokens[t];if("("===i?.content){const e=this.findExpression(t+1);if(t=e.index,")"!==this.tokens[t]?.content)throw Error("parentheses is not match");return new u(t+1,"expression",e.ast)}if("integer"===i.type)return new u(t+1,i.type,new n(i.content));if("symbol"===i.type)return new u(t+1,i.type,new h(i.content));if("function"===i.type&&"("===this.tokens[t+1].content){const e=this.findExpression(t+2);if(t=e.index,")"!==this.tokens[t]?.content)throw Error("parentheses is not match");const s={};return s.functionName=i.content,s.parameter=e.ast,new u(t+1,i.type,new o(i.content,e.ast))}if("+"===i?.content){const i=this.findTerm(e+1),s=new r("positive",i.ast);return t=i.index,new u(t,"expression",s)}if("-"===i?.content){const i=this.findTerm(e+1),s=new r("negative",i.ast);return t=i.index,new u(t,"expression",s)}}findFactor(e){const t=this.findPower(e);let i=t.index;const s=new a(t.ast);if("^"===this.tokens[i]?.content){const e=this.findPower(i+1);s.add(e.ast),i=e.index}return new u(i,"term",s.getSimplify())}findTerm(e){const t=this.findFactor(e);let i=t.index;const s=new c(t.ast);for(;;)if("*"===this.tokens[i]?.content){const e=this.findFactor(i+1);s.add("multiply",e.ast),i=e.index}else{if("/"!==this.tokens[i]?.content)break;{const e=this.findFactor(i+1);s.add("divide",e.ast),i=e.index}}return new u(i,"term",s.getSimplify())}findExpression(e){const t=this.findTerm(e);let i=t.index;const s=new l(t.ast);for(;;)if("+"===this.tokens[i]?.content){const e=this.findTerm(i+1);s.add("add",e.ast),i=e.index}else{if("-"!==this.tokens[i]?.content)break;{const e=this.findTerm(i+1);s.add("minus",e.ast),i=e.index}}return new u(i,"unaryExpression",s.getSimplify())}findUnaryExpression(e){const t=this.tokens[e];let i,s=e;if("+"===t?.content){const t=this.findUnaryExpression(e+1);i=new r("positive",t.ast),s=t.index}else if("-"===t?.content){const t=this.findUnaryExpression(e+1);i=new r("negative",t.ast),s=t.index}else{const t=this.findUnaryExpression(e);i=t.ast,s=t.index}return new u(s,"expression",i)}parse(){return this.findExpression(0)}}return t})()}));